#const width=12.
#const length=42.
#const num_mines=3.
#const num_bases=4.
#const base_base_rad=10.
#const base_lava_rad=3.
#const num_volcanoes=1.
#const volcano_radius=1.

dim(1..width).

start(1,1).
bases(num_bases).
finish(width,width).
step(0,-1 ;; 0,1 ;; 1,0 ;; -1,0).

num_volcanoes { volcano(X,Y) :dim(X) :dim(Y)  } num_volcanoes.
lava(NX,NY,0) :- volcano(X,Y),
	step(DX,DY),
	NX = X + DX,
	NY = Y + DY.%, solid(X,Y).
lava(NX,NY, T+1) :-
	lava(X,Y, T),
	T < (volcano_radius - 1),
	step(DX,DY),
	NX = X + DX,
	NY = Y + DY,
	dim(NX),
	dim(NY).
num_mines { mine(X,Y) :dim(X) :dim(Y) } num_mines.

%the following inspired by the at rule in the tutorial, and posts on Piazza
check_distance(X0,Y0,X1,Y1,D) :-
	X0 = X1,
	Y0 = Y1.
check_distance(X0,Y0,X1,Y1,D+1) :-
	check_distance(X0,Y0,NX1,NY1,D),
	step(DX,DY),
	NX1 = X1 + DX,
	NY1 = Y1 + DY,
	dim(NX1),
	dim(NY1).
	


islava(X,Y) :- lava(X,Y,I), dim(X;Y).%volcano_radius).
{ solid(X,Y) } :- dim(X), dim(Y), not mine(X,Y), not volcano(X,Y), not islava(X,Y).
lava_integrity :- islava(X,Y), not solid(X,Y), dim(X;Y).
:- not lava_integrity.

bases_too_close(X,Y) :-
	dim(NX;NY),
	base(NX,NY),
	not check_distance(X,Y,NX,NY,base_base_rad).
base_near_lava(X,Y) :-
	dim(NX,NY),
	islava(NX,NY),
	not(check_distance(X,Y,NX,NY,base_lava_rad).

%If the position is reachable, and it's not lava or a volcano, it is valid
base_positioner(X,Y) :- reachable(X,Y),
	not islava(X,Y),
	not volcano(X,Y),
	not bases_too_close(X,Y).
{ base(X,Y) } :- base_positioner(X,Y), dim(X;Y).
:- not num_bases { base(X,Y) }.
	
	
	


%bases
%1 { base(X,Y,N) :dim(X;Y) :solid(X,Y) :reachable(X,Y) } 1 :- bases(B), N = 1..B.
%base(X,Y) :- 

%others_distant(X,Y,D) :- 
%	base(A,B),
	

%base(X,Y) :- dim(X;Y), solid(X,Y), reachable(X,Y), others_distant(X,Y, base_dist).
%num_bases { base(X,Y) :dim(X) :dim(Y) }.

reachable(X,Y) :- start(X,Y), solid(X,Y).

reachable(NX,NY) :-
	reachable(X,Y),
	step(DX,DY),
	NX = X + DX,
	NY = Y + DY,
	solid(NX,NY).

%river_tile(X,Y) :- 
%	X is width 

%mine(X,Y) :- dim(X;Y), solid(X,Y).
%mines { mine(X,Y) :dim(X) :dim(Y) }.
%:- not mines { mine(X,Y) }.



at(X,Y, 0) :- start(X,Y), solid(X,Y).
at(NX,NY, T+1) :-
	at(X,Y, T),
	T < length,
	solid(NX,NY),
	step(DX,DY),
	NX = X + DX,
	NY = Y + DY,
	solid(NX,NY).

complete :- finish(X,Y), reachable(X,Y).
speedrun :- finish(X,Y), at(X,Y,T).







%lake(X,Y) :- dim(X;Y), solid(X+DX,Y+DY):step(DX,DY), not solid(X,Y).
%:- not 35 { lake(X,Y) }.




%:- bases_reachable.
:- speedrun.
:- not complete.
